worker_processes auto;

# By default, Nginx clears almost all environment variables before spawning worker processes, for security.
# Allow these env vars to pass into workers.
env POSTGRES_HOST;
env POSTGRES_PORT;
env POSTGRES_DB;
env POSTGRES_USER;
env POSTGRES_PASSWORD;
env OIDC_CLIENT_ID;
env OIDC_CLIENT_SECRET;
env OIDC_ISSUER_PUBLIC;
env OIDC_ISSUER_INTERNAL;
env OIDC_REDIRECT_URI;

events {
    worker_connections 1024;
}

http {
    # Point to Docker’s built-in DNS (common in Docker Compose),
    # e.g. `no resolver defined to resolve "hubdb"`.
    resolver 127.0.0.11;

    # Set the limit to 1000MB (adjust as needed)
    client_max_body_size 1000M;

    # timeout settings
    proxy_connect_timeout   600s;   # time to connect to upstream
    proxy_send_timeout      600s;   # timeout for sending request to upstream
    proxy_read_timeout      600s;   # timeout for reading response from upstream
    send_timeout            600s;   # timeout for sending response to client

    # By default, OpenResty/OpenResty’s mime.types may not be loaded.
    # Without correct MIME types, .css files are served as text/plain, .js as text/plain.
    # Browsers reject them because they expect text/css or application/javascript.
    include       /usr/local/openresty/nginx/conf/mime.types;
    default_type  application/octet-stream;

    # But $connection_upgrade is not a built-in variable — Nginx doesn’t define it automatically. You need to define it with a map block.
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # Set the search path for your custom Lua modules.
    # The ';;' at the end tells OpenResty to also look in the default paths.
    lua_package_path "/etc/openresty/lua/?.lua;;";

    # Required for OIDC discovery and token caching.
    lua_shared_dict discovery 1m;
    lua_shared_dict jwks 1m;

    # Required for session management (lua-resty-openidc uses lua-resty-session).
    lua_shared_dict sessions 10m;

    # Optional: redirect HTTP to HTTPS
    server {
        listen 80;
        return 301 https://$host$request_uri;
    }

    # Enable SSL
    server {
        listen 443 ssl;

        ssl_certificate     /etc/ssl/cert/openresty.crt;
        ssl_certificate_key /etc/ssl/cert/openresty.key;

        ssl_protocols       TLSv1.2 TLSv1.3;
        ssl_ciphers         HIGH:!aNULL:!MD5;

        # Trust the internal CA.
        proxy_ssl_trusted_certificate /etc/ssl/ca/rootCA.crt;
        proxy_ssl_verify on;
        proxy_ssl_verify_depth 2;
        proxy_ssl_server_name on;
        proxy_ssl_name localhost;

        location / {
            access_by_lua_block {
                -- Import the module and call the authenticate function
                local auth = require("auth")
                auth.authenticate()
            }

            # root   /usr/local/openresty/nginx/html;
            # index  index.html;
            # try_files $uri $uri/ =404;

           # After authentication, it proxies to your actual backend
            proxy_pass https://172.17.0.1:9900/;
            
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Required for WebSocket support.
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # In short: both ensure real-time WebSocket traffic works correctly and URL paths from the service are preserved.
            proxy_buffering off;
            proxy_redirect off;
        }

        # This block will catch the KeyCloak request to authenticate the user.
        location /redirect_uri {
            access_by_lua_block {
                local auth = require("auth")
                auth.authenticate()
            }
        }

        location /iam/ {
            proxy_pass http://keycloak:8080/iam/;

            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Port 9990;
        }
    }
}

# stream {
#     # This exposes postgres database to the internet.
#     upstream postgres {
#         server postgres:5432;
#     }
#     server {
#         listen 5432 so_keepalive=on; # so_keepalive=on - this helps ensure that broken or dead client connections are detected and cleaned up by the kernel, improving resource handling and avoiding stale idle connections.
#         proxy_pass postgres;
#     }
# }