# Stage 1: Build dependencies
FROM python:3.11-slim AS builder

# Set the working directory inside the container.
WORKDIR /service

# Assuming this file is right next to Dockerfile.
COPY requirements.txt .

# Install dependencies without caching to reduce image size and store them in a temporary location.
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt

# Stage 2: Final image
# Use the an optimised version of Linux with Python as the base image.
# This minimizes the final image size by installing dependencies in a temporary stage and copying only the necessary files. ðŸš€
FROM python:3.11-slim

# Set the working directory inside the container.
WORKDIR /service

# Copy installed dependencies from the builder stage to the final image to keep it lightweight.
COPY --from=builder /install /usr/local

# Assuming this folder is right next to Dockerfile.
COPY . .

# Set environment variables to avoid user interaction during package installation.
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# Ensure Streamlit config disables usage stats.
RUN mkdir -p ~/.streamlit && \
    echo "[browser]" > ~/.streamlit/config.toml && \
    echo "gatherUsageStats = false" >> ~/.streamlit/config.toml

# Classic choice of port for Streamlit. It could be re-wired when starting the container.
EXPOSE 8501

# Why CMD and not ENTRYPOINT?
# CMD is used because it allows flexibilityâ€”if a user wants to override the command (e.g., run a different FastAPI app or shell into the container), they can do so easily. ENTRYPOINT, on the other hand, is more rigid and is typically used when the container should always run a specific executable.
# CMD ["streamlit", "run", "app.py", "--server.address=0.0.0.0"]
